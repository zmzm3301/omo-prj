{"ast":null,"code":"var _slicedToArray = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar OldSelector = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function OldSelector(selector, prefix) {\n    _classCallCheck(this, OldSelector);\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(function (x) {\n      return [selector.prefixed(x), selector.regexp(x)];\n    });\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n  _createClass(OldSelector, [{\n    key: \"isHack\",\n    value: function isHack(rule) {\n      var index = rule.parent.index(rule) + 1;\n      var rules = rule.parent.nodes;\n      while (index < rules.length) {\n        var before = rules[index].selector;\n        if (!before) {\n          return true;\n        }\n        if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n          return false;\n        }\n        var some = false;\n        var _iterator = _createForOfIteratorHelper(this.prefixeds),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              string = _step$value[0],\n              regexp = _step$value[1];\n            if (before.includes(string) && before.match(regexp)) {\n              some = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!some) {\n          return true;\n        }\n        index += 1;\n      }\n      return true;\n    }\n\n    /**\n     * Does rule contain an unnecessary prefixed selector\n     */\n  }, {\n    key: \"check\",\n    value: function check(rule) {\n      if (!rule.selector.includes(this.prefixed)) {\n        return false;\n      }\n      if (!rule.selector.match(this.regexp)) {\n        return false;\n      }\n      if (this.isHack(rule)) {\n        return false;\n      }\n      return true;\n    }\n  }]);\n  return OldSelector;\n}();\nmodule.exports = OldSelector;","map":{"version":3,"names":["OldSelector","selector","prefix","prefixed","regexp","prefixeds","possible","map","x","unprefixed","name","nameRegexp","rule","index","parent","rules","nodes","length","before","includes","match","some","string","isHack","module","exports"],"sources":["C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/autoprefixer/lib/old-selector.js"],"sourcesContent":["class OldSelector {\n  constructor(selector, prefix) {\n    this.prefix = prefix\n    this.prefixed = selector.prefixed(this.prefix)\n    this.regexp = selector.regexp(this.prefix)\n\n    this.prefixeds = selector\n      .possible()\n      .map(x => [selector.prefixed(x), selector.regexp(x)])\n\n    this.unprefixed = selector.name\n    this.nameRegexp = selector.regexp()\n  }\n\n  /**\n   * Is rule a hack without unprefixed version bottom\n   */\n  isHack(rule) {\n    let index = rule.parent.index(rule) + 1\n    let rules = rule.parent.nodes\n\n    while (index < rules.length) {\n      let before = rules[index].selector\n      if (!before) {\n        return true\n      }\n\n      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n        return false\n      }\n\n      let some = false\n      for (let [string, regexp] of this.prefixeds) {\n        if (before.includes(string) && before.match(regexp)) {\n          some = true\n          break\n        }\n      }\n\n      if (!some) {\n        return true\n      }\n\n      index += 1\n    }\n\n    return true\n  }\n\n  /**\n   * Does rule contain an unnecessary prefixed selector\n   */\n  check(rule) {\n    if (!rule.selector.includes(this.prefixed)) {\n      return false\n    }\n    if (!rule.selector.match(this.regexp)) {\n      return false\n    }\n    if (this.isHack(rule)) {\n      return false\n    }\n    return true\n  }\n}\n\nmodule.exports = OldSelector\n"],"mappings":";;;;IAAMA,WAAW;EAAA;;EACf,qBAAYC,QAAQ,EAAEC,MAAM,EAAE;IAAA;IAC5B,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,QAAQ,GAAGF,QAAQ,CAACE,QAAQ,CAAC,IAAI,CAACD,MAAM,CAAC;IAC9C,IAAI,CAACE,MAAM,GAAGH,QAAQ,CAACG,MAAM,CAAC,IAAI,CAACF,MAAM,CAAC;IAE1C,IAAI,CAACG,SAAS,GAAGJ,QAAQ,CACtBK,QAAQ,EAAE,CACVC,GAAG,CAAC,UAAAC,CAAC;MAAA,OAAI,CAACP,QAAQ,CAACE,QAAQ,CAACK,CAAC,CAAC,EAAEP,QAAQ,CAACG,MAAM,CAACI,CAAC,CAAC,CAAC;IAAA,EAAC;IAEvD,IAAI,CAACC,UAAU,GAAGR,QAAQ,CAACS,IAAI;IAC/B,IAAI,CAACC,UAAU,GAAGV,QAAQ,CAACG,MAAM,EAAE;EACrC;;EAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,gBAAOQ,IAAI,EAAE;MACX,IAAIC,KAAK,GAAGD,IAAI,CAACE,MAAM,CAACD,KAAK,CAACD,IAAI,CAAC,GAAG,CAAC;MACvC,IAAIG,KAAK,GAAGH,IAAI,CAACE,MAAM,CAACE,KAAK;MAE7B,OAAOH,KAAK,GAAGE,KAAK,CAACE,MAAM,EAAE;QAC3B,IAAIC,MAAM,GAAGH,KAAK,CAACF,KAAK,CAAC,CAACZ,QAAQ;QAClC,IAAI,CAACiB,MAAM,EAAE;UACX,OAAO,IAAI;QACb;QAEA,IAAIA,MAAM,CAACC,QAAQ,CAAC,IAAI,CAACV,UAAU,CAAC,IAAIS,MAAM,CAACE,KAAK,CAAC,IAAI,CAACT,UAAU,CAAC,EAAE;UACrE,OAAO,KAAK;QACd;QAEA,IAAIU,IAAI,GAAG,KAAK;QAAA,2CACa,IAAI,CAAChB,SAAS;UAAA;QAAA;UAA3C,oDAA6C;YAAA;cAAnCiB,MAAM;cAAElB,MAAM;YACtB,IAAIc,MAAM,CAACC,QAAQ,CAACG,MAAM,CAAC,IAAIJ,MAAM,CAACE,KAAK,CAAChB,MAAM,CAAC,EAAE;cACnDiB,IAAI,GAAG,IAAI;cACX;YACF;UACF;QAAC;UAAA;QAAA;UAAA;QAAA;QAED,IAAI,CAACA,IAAI,EAAE;UACT,OAAO,IAAI;QACb;QAEAR,KAAK,IAAI,CAAC;MACZ;MAEA,OAAO,IAAI;IACb;;IAEA;AACF;AACA;EAFE;IAAA;IAAA,OAGA,eAAMD,IAAI,EAAE;MACV,IAAI,CAACA,IAAI,CAACX,QAAQ,CAACkB,QAAQ,CAAC,IAAI,CAAChB,QAAQ,CAAC,EAAE;QAC1C,OAAO,KAAK;MACd;MACA,IAAI,CAACS,IAAI,CAACX,QAAQ,CAACmB,KAAK,CAAC,IAAI,CAAChB,MAAM,CAAC,EAAE;QACrC,OAAO,KAAK;MACd;MACA,IAAI,IAAI,CAACmB,MAAM,CAACX,IAAI,CAAC,EAAE;QACrB,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb;EAAC;EAAA;AAAA;AAGHY,MAAM,CAACC,OAAO,GAAGzB,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}