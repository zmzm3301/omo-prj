{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require('postcss'),\n  list = _require.list;\nvar OldSelector = require('./old-selector');\nvar Prefixer = require('./prefixer');\nvar Browsers = require('./browsers');\nvar utils = require('./utils');\nvar Selector = /*#__PURE__*/function (_Prefixer) {\n  \"use strict\";\n\n  _inherits(Selector, _Prefixer);\n  var _super = _createSuper(Selector);\n  function Selector(name, prefixes, all) {\n    var _this;\n    _classCallCheck(this, Selector);\n    _this = _super.call(this, name, prefixes, all);\n    _this.regexpCache = new Map();\n    return _this;\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  _createClass(Selector, [{\n    key: \"check\",\n    value: function check(rule) {\n      if (rule.selector.includes(this.name)) {\n        return !!rule.selector.match(this.regexp());\n      }\n      return false;\n    }\n\n    /**\n     * Return prefixed version of selector\n     */\n  }, {\n    key: \"prefixed\",\n    value: function prefixed(prefix) {\n      return this.name.replace(/^(\\W*)/, \"$1\".concat(prefix));\n    }\n\n    /**\n     * Lazy loadRegExp for name\n     */\n  }, {\n    key: \"regexp\",\n    value: function regexp(prefix) {\n      if (!this.regexpCache.has(prefix)) {\n        var name = prefix ? this.prefixed(prefix) : this.name;\n        this.regexpCache.set(prefix, new RegExp(\"(^|[^:\\\"'=])\".concat(utils.escapeRegexp(name)), 'gi'));\n      }\n      return this.regexpCache.get(prefix);\n    }\n\n    /**\n     * All possible prefixes\n     */\n  }, {\n    key: \"possible\",\n    value: function possible() {\n      return Browsers.prefixes();\n    }\n\n    /**\n     * Return all possible selector prefixes\n     */\n  }, {\n    key: \"prefixeds\",\n    value: function prefixeds(rule) {\n      var _this2 = this;\n      if (rule._autoprefixerPrefixeds) {\n        if (rule._autoprefixerPrefixeds[this.name]) {\n          return rule._autoprefixerPrefixeds;\n        }\n      } else {\n        rule._autoprefixerPrefixeds = {};\n      }\n      var prefixeds = {};\n      if (rule.selector.includes(',')) {\n        var ruleParts = list.comma(rule.selector);\n        var toProcess = ruleParts.filter(function (el) {\n          return el.includes(_this2.name);\n        });\n        var _iterator = _createForOfIteratorHelper(this.possible()),\n          _step;\n        try {\n          var _loop = function _loop() {\n            var prefix = _step.value;\n            prefixeds[prefix] = toProcess.map(function (el) {\n              return _this2.replace(el, prefix);\n            }).join(', ');\n          };\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(this.possible()),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var prefix = _step2.value;\n            prefixeds[prefix] = this.replace(rule.selector, prefix);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      rule._autoprefixerPrefixeds[this.name] = prefixeds;\n      return rule._autoprefixerPrefixeds;\n    }\n\n    /**\n     * Is rule already prefixed before\n     */\n  }, {\n    key: \"already\",\n    value: function already(rule, prefixeds, prefix) {\n      var index = rule.parent.index(rule) - 1;\n      while (index >= 0) {\n        var before = rule.parent.nodes[index];\n        if (before.type !== 'rule') {\n          return false;\n        }\n        var some = false;\n        for (var key in prefixeds[this.name]) {\n          var prefixed = prefixeds[this.name][key];\n          if (before.selector === prefixed) {\n            if (prefix === key) {\n              return true;\n            } else {\n              some = true;\n              break;\n            }\n          }\n        }\n        if (!some) {\n          return false;\n        }\n        index -= 1;\n      }\n      return false;\n    }\n\n    /**\n     * Replace selectors by prefixed one\n     */\n  }, {\n    key: \"replace\",\n    value: function replace(selector, prefix) {\n      return selector.replace(this.regexp(), \"$1\".concat(this.prefixed(prefix)));\n    }\n\n    /**\n     * Clone and add prefixes for at-rule\n     */\n  }, {\n    key: \"add\",\n    value: function add(rule, prefix) {\n      var prefixeds = this.prefixeds(rule);\n      if (this.already(rule, prefixeds, prefix)) {\n        return;\n      }\n      var cloned = this.clone(rule, {\n        selector: prefixeds[this.name][prefix]\n      });\n      rule.parent.insertBefore(rule, cloned);\n    }\n\n    /**\n     * Return function to fast find prefixed selector\n     */\n  }, {\n    key: \"old\",\n    value: function old(prefix) {\n      return new OldSelector(this, prefix);\n    }\n  }]);\n  return Selector;\n}(Prefixer);\nmodule.exports = Selector;","map":{"version":3,"names":["require","list","OldSelector","Prefixer","Browsers","utils","Selector","name","prefixes","all","regexpCache","Map","rule","selector","includes","match","regexp","prefix","replace","has","prefixed","set","RegExp","escapeRegexp","get","_autoprefixerPrefixeds","prefixeds","ruleParts","comma","toProcess","filter","el","possible","map","join","index","parent","before","nodes","type","some","key","already","cloned","clone","insertBefore","module","exports"],"sources":["C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/autoprefixer/lib/selector.js"],"sourcesContent":["let { list } = require('postcss')\n\nlet OldSelector = require('./old-selector')\nlet Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all)\n    this.regexpCache = new Map()\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp())\n    }\n\n    return false\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`)\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name\n      this.regexpCache.set(\n        prefix,\n        new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi')\n      )\n    }\n\n    return this.regexpCache.get(prefix)\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes()\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {}\n    }\n\n    let prefixeds = {}\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector)\n      let toProcess = ruleParts.filter(el => el.includes(this.name))\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess\n          .map(el => this.replace(el, prefix))\n          .join(', ')\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix)\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds\n    return rule._autoprefixerPrefixeds\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index]\n\n      if (before.type !== 'rule') {\n        return false\n      }\n\n      let some = false\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key]\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true\n          } else {\n            some = true\n            break\n          }\n        }\n      }\n      if (!some) {\n        return false\n      }\n\n      index -= 1\n    }\n\n    return false\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule)\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return\n    }\n\n    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })\n    rule.parent.insertBefore(rule, cloned)\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix)\n  }\n}\n\nmodule.exports = Selector\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}