{"ast":null,"code":"var _slicedToArray = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require('postcss'),\n  list = _require.list;\nvar parser = require('postcss-value-parser');\nvar Browsers = require('./browsers');\nvar vendor = require('./vendor');\nvar Transition = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Transition(prefixes) {\n    _classCallCheck(this, Transition);\n    this.props = ['transition', 'transition-property'];\n    this.prefixes = prefixes;\n  }\n\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n  _createClass(Transition, [{\n    key: \"add\",\n    value: function add(decl, result) {\n      var _this = this;\n      var prefix, prop;\n      var add = this.prefixes.add[decl.prop];\n      var vendorPrefixes = this.ruleVendorPrefixes(decl);\n      var declPrefixes = vendorPrefixes || add && add.prefixes || [];\n      var params = this.parse(decl.value);\n      var names = params.map(function (i) {\n        return _this.findProp(i);\n      });\n      var added = [];\n      if (names.some(function (i) {\n        return i[0] === '-';\n      })) {\n        return;\n      }\n      var _iterator = _createForOfIteratorHelper(params),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var param = _step.value;\n          prop = this.findProp(param);\n          if (prop[0] === '-') continue;\n          var prefixer = this.prefixes.add[prop];\n          if (!prefixer || !prefixer.prefixes) continue;\n          var _iterator3 = _createForOfIteratorHelper(prefixer.prefixes),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              prefix = _step3.value;\n              if (vendorPrefixes && !vendorPrefixes.some(function (p) {\n                return prefix.includes(p);\n              })) {\n                continue;\n              }\n              var prefixed = this.prefixes.prefixed(prop, prefix);\n              if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n                if (!this.disabled(prop, prefix)) {\n                  added.push(this.clone(prop, prefixed, param));\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      params = params.concat(added);\n      var value = this.stringify(params);\n      var webkitClean = this.stringify(this.cleanFromUnprefixed(params, '-webkit-'));\n      if (declPrefixes.includes('-webkit-')) {\n        this.cloneBefore(decl, \"-webkit-\".concat(decl.prop), webkitClean);\n      }\n      this.cloneBefore(decl, decl.prop, webkitClean);\n      if (declPrefixes.includes('-o-')) {\n        var operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'));\n        this.cloneBefore(decl, \"-o-\".concat(decl.prop), operaClean);\n      }\n      var _iterator2 = _createForOfIteratorHelper(declPrefixes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          prefix = _step2.value;\n          if (prefix !== '-webkit-' && prefix !== '-o-') {\n            var prefixValue = this.stringify(this.cleanOtherPrefixes(params, prefix));\n            this.cloneBefore(decl, prefix + decl.prop, prefixValue);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n        this.checkForWarning(result, decl);\n        decl.cloneBefore();\n        decl.value = value;\n      }\n    }\n\n    /**\n     * Find property name\n     */\n  }, {\n    key: \"findProp\",\n    value: function findProp(param) {\n      var prop = param[0].value;\n      if (/^\\d/.test(prop)) {\n        var _iterator4 = _createForOfIteratorHelper(param.entries()),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n              i = _step4$value[0],\n              token = _step4$value[1];\n            if (i !== 0 && token.type === 'word') {\n              return token.value;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      return prop;\n    }\n\n    /**\n     * Does we already have this declaration\n     */\n  }, {\n    key: \"already\",\n    value: function already(decl, prop, value) {\n      return decl.parent.some(function (i) {\n        return i.prop === prop && i.value === value;\n      });\n    }\n\n    /**\n     * Add declaration if it is not exist\n     */\n  }, {\n    key: \"cloneBefore\",\n    value: function cloneBefore(decl, prop, value) {\n      if (!this.already(decl, prop, value)) {\n        decl.cloneBefore({\n          prop: prop,\n          value: value\n        });\n      }\n    }\n\n    /**\n     * Show transition-property warning\n     */\n  }, {\n    key: \"checkForWarning\",\n    value: function checkForWarning(result, decl) {\n      var _this2 = this;\n      if (decl.prop !== 'transition-property') {\n        return;\n      }\n      var isPrefixed = false;\n      var hasAssociatedProp = false;\n      decl.parent.each(function (i) {\n        if (i.type !== 'decl') {\n          return undefined;\n        }\n        if (i.prop.indexOf('transition-') !== 0) {\n          return undefined;\n        }\n        var values = list.comma(i.value);\n        // check if current Rule's transition-property comma separated value list needs prefixes\n        if (i.prop === 'transition-property') {\n          values.forEach(function (value) {\n            var lookup = _this2.prefixes.add[value];\n            if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n              isPrefixed = true;\n            }\n          });\n          return undefined;\n        }\n        // check if another transition-* prop in current Rule has comma separated value list\n        hasAssociatedProp = hasAssociatedProp || values.length > 1;\n        return false;\n      });\n      if (isPrefixed && hasAssociatedProp) {\n        decl.warn(result, 'Replace transition-property to transition, ' + 'because Autoprefixer could not support ' + 'any cases of transition-property ' + 'and other transition-*');\n      }\n    }\n\n    /**\n     * Process transition and remove all unnecessary properties\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(decl) {\n      var _this3 = this;\n      var params = this.parse(decl.value);\n      params = params.filter(function (i) {\n        var prop = _this3.prefixes.remove[_this3.findProp(i)];\n        return !prop || !prop.remove;\n      });\n      var value = this.stringify(params);\n      if (decl.value === value) {\n        return;\n      }\n      if (params.length === 0) {\n        decl.remove();\n        return;\n      }\n      var double = decl.parent.some(function (i) {\n        return i.prop === decl.prop && i.value === value;\n      });\n      var smaller = decl.parent.some(function (i) {\n        return i !== decl && i.prop === decl.prop && i.value.length > value.length;\n      });\n      if (double || smaller) {\n        decl.remove();\n        return;\n      }\n      decl.value = value;\n    }\n\n    /**\n     * Parse properties list to array\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(value) {\n      var ast = parser(value);\n      var result = [];\n      var param = [];\n      var _iterator5 = _createForOfIteratorHelper(ast.nodes),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var node = _step5.value;\n          param.push(node);\n          if (node.type === 'div' && node.value === ',') {\n            result.push(param);\n            param = [];\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      result.push(param);\n      return result.filter(function (i) {\n        return i.length > 0;\n      });\n    }\n\n    /**\n     * Return properties string from array\n     */\n  }, {\n    key: \"stringify\",\n    value: function stringify(params) {\n      if (params.length === 0) {\n        return '';\n      }\n      var nodes = [];\n      var _iterator6 = _createForOfIteratorHelper(params),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var param = _step6.value;\n          if (param[param.length - 1].type !== 'div') {\n            param.push(this.div(params));\n          }\n          nodes = nodes.concat(param);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      if (nodes[0].type === 'div') {\n        nodes = nodes.slice(1);\n      }\n      if (nodes[nodes.length - 1].type === 'div') {\n        nodes = nodes.slice(0, +-2 + 1 || undefined);\n      }\n      return parser.stringify({\n        nodes: nodes\n      });\n    }\n\n    /**\n     * Return new param array with different name\n     */\n  }, {\n    key: \"clone\",\n    value: function clone(origin, name, param) {\n      var result = [];\n      var changed = false;\n      var _iterator7 = _createForOfIteratorHelper(param),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n          if (!changed && i.type === 'word' && i.value === origin) {\n            result.push({\n              type: 'word',\n              value: name\n            });\n            changed = true;\n          } else {\n            result.push(i);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return result;\n    }\n\n    /**\n     * Find or create separator\n     */\n  }, {\n    key: \"div\",\n    value: function div(params) {\n      var _iterator8 = _createForOfIteratorHelper(params),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var param = _step8.value;\n          var _iterator9 = _createForOfIteratorHelper(param),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var node = _step9.value;\n              if (node.type === 'div' && node.value === ',') {\n                return node;\n              }\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      return {\n        type: 'div',\n        value: ',',\n        after: ' '\n      };\n    }\n  }, {\n    key: \"cleanOtherPrefixes\",\n    value: function cleanOtherPrefixes(params, prefix) {\n      var _this4 = this;\n      return params.filter(function (param) {\n        var current = vendor.prefix(_this4.findProp(param));\n        return current === '' || current === prefix;\n      });\n    }\n\n    /**\n     * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n     */\n  }, {\n    key: \"cleanFromUnprefixed\",\n    value: function cleanFromUnprefixed(params, prefix) {\n      var _this5 = this;\n      var remove = params.map(function (i) {\n        return _this5.findProp(i);\n      }).filter(function (i) {\n        return i.slice(0, prefix.length) === prefix;\n      }).map(function (i) {\n        return _this5.prefixes.unprefixed(i);\n      });\n      var result = [];\n      var _iterator10 = _createForOfIteratorHelper(params),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var param = _step10.value;\n          var prop = this.findProp(param);\n          var p = vendor.prefix(prop);\n          if (!remove.includes(prop) && (p === prefix || p === '')) {\n            result.push(param);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      return result;\n    }\n\n    /**\n     * Check property for disabled by option\n     */\n  }, {\n    key: \"disabled\",\n    value: function disabled(prop, prefix) {\n      var other = ['order', 'justify-content', 'align-self', 'align-content'];\n      if (prop.includes('flex') || other.includes(prop)) {\n        if (this.prefixes.options.flexbox === false) {\n          return true;\n        }\n        if (this.prefixes.options.flexbox === 'no-2009') {\n          return prefix.includes('2009');\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Check if transition prop is inside vendor specific rule\n     */\n  }, {\n    key: \"ruleVendorPrefixes\",\n    value: function ruleVendorPrefixes(decl) {\n      var parent = decl.parent;\n      if (parent.type !== 'rule') {\n        return false;\n      } else if (!parent.selector.includes(':-')) {\n        return false;\n      }\n      var selectors = Browsers.prefixes().filter(function (s) {\n        return parent.selector.includes(':' + s);\n      });\n      return selectors.length > 0 ? selectors : false;\n    }\n  }]);\n  return Transition;\n}();\nmodule.exports = Transition;","map":{"version":3,"names":["require","list","parser","Browsers","vendor","Transition","prefixes","props","decl","result","prefix","prop","add","vendorPrefixes","ruleVendorPrefixes","declPrefixes","params","parse","value","names","map","i","findProp","added","some","param","prefixer","p","includes","prefixed","disabled","push","clone","concat","stringify","webkitClean","cleanFromUnprefixed","cloneBefore","operaClean","prefixValue","cleanOtherPrefixes","already","checkForWarning","test","entries","token","type","parent","isPrefixed","hasAssociatedProp","each","undefined","indexOf","values","comma","forEach","lookup","length","warn","filter","remove","double","smaller","ast","nodes","node","div","slice","origin","name","changed","after","current","unprefixed","other","options","flexbox","selector","selectors","s","module","exports"],"sources":["C:/Users/zmzm3/git/omo/omo-prj/src/main/react-prj-sample-main/node_modules/autoprefixer/lib/transition.js"],"sourcesContent":["let { list } = require('postcss')\nlet parser = require('postcss-value-parser')\n\nlet Browsers = require('./browsers')\nlet vendor = require('./vendor')\n\nclass Transition {\n  constructor(prefixes) {\n    this.props = ['transition', 'transition-property']\n    this.prefixes = prefixes\n  }\n\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n  add(decl, result) {\n    let prefix, prop\n    let add = this.prefixes.add[decl.prop]\n    let vendorPrefixes = this.ruleVendorPrefixes(decl)\n    let declPrefixes = vendorPrefixes || (add && add.prefixes) || []\n\n    let params = this.parse(decl.value)\n    let names = params.map(i => this.findProp(i))\n    let added = []\n\n    if (names.some(i => i[0] === '-')) {\n      return\n    }\n\n    for (let param of params) {\n      prop = this.findProp(param)\n      if (prop[0] === '-') continue\n\n      let prefixer = this.prefixes.add[prop]\n      if (!prefixer || !prefixer.prefixes) continue\n\n      for (prefix of prefixer.prefixes) {\n        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {\n          continue\n        }\n\n        let prefixed = this.prefixes.prefixed(prop, prefix)\n        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n          if (!this.disabled(prop, prefix)) {\n            added.push(this.clone(prop, prefixed, param))\n          }\n        }\n      }\n    }\n\n    params = params.concat(added)\n    let value = this.stringify(params)\n\n    let webkitClean = this.stringify(\n      this.cleanFromUnprefixed(params, '-webkit-')\n    )\n    if (declPrefixes.includes('-webkit-')) {\n      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean)\n    }\n    this.cloneBefore(decl, decl.prop, webkitClean)\n    if (declPrefixes.includes('-o-')) {\n      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'))\n      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean)\n    }\n\n    for (prefix of declPrefixes) {\n      if (prefix !== '-webkit-' && prefix !== '-o-') {\n        let prefixValue = this.stringify(\n          this.cleanOtherPrefixes(params, prefix)\n        )\n        this.cloneBefore(decl, prefix + decl.prop, prefixValue)\n      }\n    }\n\n    if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n      this.checkForWarning(result, decl)\n      decl.cloneBefore()\n      decl.value = value\n    }\n  }\n\n  /**\n   * Find property name\n   */\n  findProp(param) {\n    let prop = param[0].value\n    if (/^\\d/.test(prop)) {\n      for (let [i, token] of param.entries()) {\n        if (i !== 0 && token.type === 'word') {\n          return token.value\n        }\n      }\n    }\n    return prop\n  }\n\n  /**\n   * Does we already have this declaration\n   */\n  already(decl, prop, value) {\n    return decl.parent.some(i => i.prop === prop && i.value === value)\n  }\n\n  /**\n   * Add declaration if it is not exist\n   */\n  cloneBefore(decl, prop, value) {\n    if (!this.already(decl, prop, value)) {\n      decl.cloneBefore({ prop, value })\n    }\n  }\n\n  /**\n   * Show transition-property warning\n   */\n  checkForWarning(result, decl) {\n    if (decl.prop !== 'transition-property') {\n      return\n    }\n\n    let isPrefixed = false\n    let hasAssociatedProp = false\n\n    decl.parent.each(i => {\n      if (i.type !== 'decl') {\n        return undefined\n      }\n      if (i.prop.indexOf('transition-') !== 0) {\n        return undefined\n      }\n      let values = list.comma(i.value)\n      // check if current Rule's transition-property comma separated value list needs prefixes\n      if (i.prop === 'transition-property') {\n        values.forEach(value => {\n          let lookup = this.prefixes.add[value]\n          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n            isPrefixed = true\n          }\n        })\n        return undefined\n      }\n      // check if another transition-* prop in current Rule has comma separated value list\n      hasAssociatedProp = hasAssociatedProp || values.length > 1\n      return false\n    })\n\n    if (isPrefixed && hasAssociatedProp) {\n      decl.warn(\n        result,\n        'Replace transition-property to transition, ' +\n          'because Autoprefixer could not support ' +\n          'any cases of transition-property ' +\n          'and other transition-*'\n      )\n    }\n  }\n\n  /**\n   * Process transition and remove all unnecessary properties\n   */\n  remove(decl) {\n    let params = this.parse(decl.value)\n    params = params.filter(i => {\n      let prop = this.prefixes.remove[this.findProp(i)]\n      return !prop || !prop.remove\n    })\n    let value = this.stringify(params)\n\n    if (decl.value === value) {\n      return\n    }\n\n    if (params.length === 0) {\n      decl.remove()\n      return\n    }\n\n    let double = decl.parent.some(i => {\n      return i.prop === decl.prop && i.value === value\n    })\n    let smaller = decl.parent.some(i => {\n      return i !== decl && i.prop === decl.prop && i.value.length > value.length\n    })\n\n    if (double || smaller) {\n      decl.remove()\n      return\n    }\n\n    decl.value = value\n  }\n\n  /**\n   * Parse properties list to array\n   */\n  parse(value) {\n    let ast = parser(value)\n    let result = []\n    let param = []\n    for (let node of ast.nodes) {\n      param.push(node)\n      if (node.type === 'div' && node.value === ',') {\n        result.push(param)\n        param = []\n      }\n    }\n    result.push(param)\n    return result.filter(i => i.length > 0)\n  }\n\n  /**\n   * Return properties string from array\n   */\n  stringify(params) {\n    if (params.length === 0) {\n      return ''\n    }\n    let nodes = []\n    for (let param of params) {\n      if (param[param.length - 1].type !== 'div') {\n        param.push(this.div(params))\n      }\n      nodes = nodes.concat(param)\n    }\n    if (nodes[0].type === 'div') {\n      nodes = nodes.slice(1)\n    }\n    if (nodes[nodes.length - 1].type === 'div') {\n      nodes = nodes.slice(0, +-2 + 1 || undefined)\n    }\n    return parser.stringify({ nodes })\n  }\n\n  /**\n   * Return new param array with different name\n   */\n  clone(origin, name, param) {\n    let result = []\n    let changed = false\n    for (let i of param) {\n      if (!changed && i.type === 'word' && i.value === origin) {\n        result.push({ type: 'word', value: name })\n        changed = true\n      } else {\n        result.push(i)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Find or create separator\n   */\n  div(params) {\n    for (let param of params) {\n      for (let node of param) {\n        if (node.type === 'div' && node.value === ',') {\n          return node\n        }\n      }\n    }\n    return { type: 'div', value: ',', after: ' ' }\n  }\n\n  cleanOtherPrefixes(params, prefix) {\n    return params.filter(param => {\n      let current = vendor.prefix(this.findProp(param))\n      return current === '' || current === prefix\n    })\n  }\n\n  /**\n   * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n   */\n  cleanFromUnprefixed(params, prefix) {\n    let remove = params\n      .map(i => this.findProp(i))\n      .filter(i => i.slice(0, prefix.length) === prefix)\n      .map(i => this.prefixes.unprefixed(i))\n\n    let result = []\n    for (let param of params) {\n      let prop = this.findProp(param)\n      let p = vendor.prefix(prop)\n      if (!remove.includes(prop) && (p === prefix || p === '')) {\n        result.push(param)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Check property for disabled by option\n   */\n  disabled(prop, prefix) {\n    let other = ['order', 'justify-content', 'align-self', 'align-content']\n    if (prop.includes('flex') || other.includes(prop)) {\n      if (this.prefixes.options.flexbox === false) {\n        return true\n      }\n\n      if (this.prefixes.options.flexbox === 'no-2009') {\n        return prefix.includes('2009')\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * Check if transition prop is inside vendor specific rule\n   */\n  ruleVendorPrefixes(decl) {\n    let { parent } = decl\n\n    if (parent.type !== 'rule') {\n      return false\n    } else if (!parent.selector.includes(':-')) {\n      return false\n    }\n\n    let selectors = Browsers.prefixes().filter(s =>\n      parent.selector.includes(':' + s)\n    )\n\n    return selectors.length > 0 ? selectors : false\n  }\n}\n\nmodule.exports = Transition\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}